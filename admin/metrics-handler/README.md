# Metrics Handler
Receives messages from Rsyslog containing metrics and forwards them wherever you want!

OpenShift metrics are lines matching the following format:

	type=metric metric1=value1 metric1=value2 â€¦

If you're running something such as Graphite, Splunk, or Elasticsearch to store and display metrics, you can use this tool to forward your metrics to those services.

# Prerequisites
You'll need to install both Rsyslog 7 and the `mmopenshift` plugin for Rsyslog 7.

Additionally, you'll need to install the `syslog-logger` rubygem.

# Sample Rsyslog 7 Configuration

	module(load="imuxsock" SysSock.Annotate="on" SysSock.ParseTrusted="on" SysSock.UsePIDFromSystem="on")
	module(load="omprog")
	 
	template(name="OpenShift" type="list") {
	    property(name="timestamp" dateFormat="rfc3339")
	    constant(value=" ")
	    property(name="hostname")
	    constant(value=" ")
	    property(name="syslogtag")
	    constant(value=" app=")
	    property(name="$!OpenShift!OPENSHIFT_APP_UUID")
	    constant(value=" gear=")
	    property(name="$!OpenShift!OPENSHIFT_GEAR_UUID")
	    constant(value=" domain=")
	    property(name="$!OpenShift!OPENSHIFT_NAMESPACE")
	    property(name="msg" spifno1stsp="on")
	    property(name="msg" droplastlf="on")
	    constant(value="\n")
	}
	 
	module(load="mmopenshift")
	action(type="mmopenshift")
	
	# the Metrics Handler uses the Syslog tag 'openshift-metrics', so check
	# the tag to make sure we don't get ourselves in an infinite loop! 
	if $msg contains 'type=metric' and $programname != 'openshift-metrics' then

	  # if the message came through the mmopenshift plugin, it's been annotated
	  # with properties such as OPENSHIFT_APP_UUID, so we need to send use the
	  # 'OpenShift' template defined above so it's formatted correctly before sending
	  # it to the Metrics Handler
	  if not isempty($!OpenShift) then
	    *.* action(type="omprog" binary="/path/to/metrics_handler" template="OpenShift")
	  
	  # otherwise, we assume the message came from the Watchman Metrics plugin, which
	  # takes care of adding app=, gear=, etc to each message, so we don't need to use
	  # the 'OpenShift' template
	  else
	    *.* action(type="omprog" binary="/path/to/metrics_handler")

	# not a metrics message but it is annotated with gear metadata
	else if $!OpenShift!OPENSHIFT_APP_UUID != '' then
	  # send non-metrics gear messages to a file (but any output plugin could be used instead)
	  *.* action(type="omfile" file="/var/log/openshift_gears" template="OpenShift")

	# not a metrics message or a message from an OpenShift gear
	else
	  *.info;mail.none;authpriv.none;cron.none      action(type="omfile" file="/var/log/messages")

# Sample Metrics Handler Configuration
The default configuration file location for the Metrics Handler is `/etc/openshift/metrics_handler.yml`. If that file does not exist, the following defaults will be used:

	---
	metadata:
	- app
	- gear
	- cart
	logger: console
	
This is a complete configuration file example:

	---
	metadata:
	- app
	- gear
	- cart: {required: false}
	logger: syslog
	graphite:
	  enabled: false
	  host: localhost
	  port: 2003
	file:
	  enabled: false
	  path: /tmp/metrics.log
	stdout:
	  enabled: false

## metadata
The `metadata` configuration option is used to specify which portions of a message are considered metadata, to separate them from the metrics themselves. You can specify if a particular value is required or optional (the default is required, if not specified).

`metadata` is a list of either strings or hashes. If the value is a string, that means that particular value must be present in the message. If the value is a hash, you can specify that particular value is not required.

## logger
The `logger` configuration option is used to specify where log messages generated by the Metrics Handler should go. Valid options are `console` and `syslog`. For environments where Rsyslog is forwarding messages to the Metrics Handler, `syslog` is recommended. For user testing, `console` may make more sense (as you can invoke the Metrics Handler directly from the command line and see the output).

## \<plugin>
Each plugin can be configured by specifying the name of the plugin as a top level key in the configuration file. In the example above, `graphite:`, `file:`, and `stdout:` are entries that configure plugins. Each plugin may define its own configuration format.

All plugins are enabled by default. To disable a plugin, add `enabled: false` to its configuration section.

## graphite plugin
The Graphite plugin sends all metrics it receives to a remote Graphite/Carbon server.

The Graphite plugin currently supports the following configuration options:

- **host** host name or IP address of your graphite server
- **port** port of the graphite server

The Graphite plugin sends metrics to the Carbon server via its plain text protocol. Each metric is transmitted on its own line. All of the required metadata values and any optional metadata values that are found are concantenated in the order specified in the configuration file, followed by the metric name, to produce the full metric key to be sent to Graphite. An example of such a key might be:

	myapp.534569019023f0b1b3000047.jboss.jvm.heap.used

Where:

- **myapp** is the application name
- **534569019023f0b1b3000047** is the gear UUID
- **jboss** is the cartridge name
- **jvm.heap.used** is the metric name

## file plugin
The File plugin writes all metrics it receives to a file.

The File plugin currently supports the following configuration option:

- **path** the path to the file in which the metrics should be written

## stdout plugin
The Stdout plugin writes all metrics it receives to the console aka stdout.

# Basic operation
When Rsyslog sees a metrics message, it forwards it to the Metrics Handler. The handler will validate that the message conforms to the expected format: standard Syslog message format, followed by `type=metric`, metadata, and then 1 or more metrics. Here is a sample line containing 2 metrics `a` and `b`:

	2014-02-27T14:50:22.011665-05:00 type=metric app=app1 gear=gear1 cart=cart1 a=1 b=2
	
Each line must include a timestamp, `type=metric`, and all required metadata as specified in the configuration file. Lines that do not will be discarded.

When the handler receives a well-formed line, it sends the line to each plugin and allows each plugin to process the line.