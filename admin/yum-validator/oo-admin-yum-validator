#!/usr/bin/python -tt

"""This implements the OpenShift-specific logic for validating Yum
repositories

"""

import sys
from yumvalidator import repo_db
from yumvalidator.check_sources import CheckSources
from yumvalidator.check_sources import SubscriptionManagerError
from yumvalidator.check_sources import SUBMAN_OVERRIDE_NVR
# from yumvalidator.reconcile_rhsm_config import ReconciliationEngine
from itertools import chain
from yum import Errors
import logging
from os.path import normpath
import rpm

OSE_PRIORITY = 10
RHEL_PRIORITY = 20
JBOSS_PRIORITY = 30
OTHER_PRIORITY = 40

UNKNOWN, RHSM, RHN, YUM = ('unknown', 'rhsm', 'rhn', 'yum')
SUBS_NAME = {UNKNOWN: '', RHSM: 'Red Hat Subscription Manager',
             RHN: 'RHN Classic or RHN Satellite', YUM: 'Yum'}
VALID_SUBS = SUBS_NAME.keys()[1:]
ATTACH_ENTITLEMENTS_URL = 'https://access.redhat.com/site/articles/522923'
EAP_ROLES = ['node-eap-6.3', 'node-eap-6.4'] + ['node-eap']
VALID_ROLES = ['node', 'broker', 'client', 'node-fuse', 'node-amq'] + EAP_ROLES
WORKING_YCM_NVR = ('yum', '3.2.29', '47.el6')

def flatten_uniq(llist):
    """Flatten nested iterables and filter result for uniqueness
    """
    return list(set(chain.from_iterable(llist)))

class UnrecoverableYumError(Exception):
    """The Yum API is giving up, and so should we"""
    pass

class YumValidatorError(Exception):
    """This error should be prohibited by program logic"""
    pass

class OpenShiftYumValidator(object):
    """This class encapsulates OpenShift-specific yum validator logic

    """

    pri_header = False
    pri_resolve_header = False
    problem = False
    resolved_repos = {}
    committed_resolved_repos = {}

    def __init__(self, opts, opt_parser):
        self.opts = opts
        self.opt_parser = opt_parser
        self._setup_logger()
        self.oscs = CheckSources()
        if not self.opts.subscription:
            self.opts.subscription = UNKNOWN
        else:
            self.opts.subscription = self.opts.subscription.lower()
        if self.opts.repo_config:
            self.rdb = repo_db.RepoDB(file(self.opts.repo_config),
                                      user_repos_only=self.opts.user_repos_only)
        else:
            self.rdb = repo_db.RepoDB()
        if not hasattr(self.opts, 'product'):
            self.opts.product = None

    def _setup_logger(self):
        self.opts.loglevel = logging.INFO
        # TODO: log to file if specified, with requested severity
        self.logger = logging.getLogger(name='oo-admin-yum-validator')
        self.logger.propagate = False
        self.logger.setLevel(self.opts.loglevel)
        ch = logging.StreamHandler(sys.stdout)
        ch.setLevel(self.opts.loglevel)
        ch.setFormatter(logging.Formatter("%(message)s"))
        self.logger.addHandler(ch)
        # if self.opts.logfile:
        #     self.logger.addHandler(logfilehandler)

    def required_repos(self):
        """Return a list of RepoTuples that match the specified role,
        subscription type and oo-version

        """
        # Include the base RHEL repo in the required repos
        roles = self.opts.role + ['base']
        sub = self.opts.subscription
        o_ver = self.opts.oo_version
        return flatten_uniq([self.rdb.find_repos(subscription=sub,
                                            role=role,
                                            product_version=o_ver)
                        for role in roles])

    def required_repoids(self):
        """Return a list of repoids as Strings that match the specified role,
        subscription type and oo-version

        """
        return [repo.repoid for repo in self.required_repos()]

    def enabled_blessed_repos(self):
        """Return a list of RepoTuples from self.rdb that match repoids of
        enabled repositories

        """
        enabled = self.oscs.enabled_repoids()
        return [repo for repo in self.rdb.find_repos_by_repoid(enabled)
                if repo.subscription == self.opts.subscription
                and repo.product_version == self.opts.oo_version]

    def blessed_repoids(self, **kwargs):
        """Return a list of just repoids for the results of blessed_repos
        called with the provided arguments

        """
        return [repo.repoid for repo in self.blessed_repos(**kwargs)]

    def blessed_repos(self, enabled=False, required=False, product=None):
        """Return a list of RepoTuples from self.rdb that match the provided
        criteria

        Keyword arguments:
        enabled -- if True, constrain results to those matching the
                   repoids of currently enabled repositories
                   Default: False
        required -- if True, constrain search to the list provided by
                    required_repos
                    Default: False
        product -- if provided, constrain results to RepoTuples with a
                   product field that matches the string provided
                   Default: None
        """

        kwargs = {'subscription': self.opts.subscription,
                  'product_version': self.opts.oo_version}
        if product:
            kwargs['product'] = product
        if enabled:
            if required:
                return [repo for repo in self.required_repos()
                        if repo.repoid in self.oscs.enabled_repoids()
                        and (not product or repo.product == product)]
            return [repo for repo in self.rdb.find_repos(**kwargs)
                    if repo.repoid in self.oscs.enabled_repoids()]
        if required:
            return [repo for repo in self.required_repos()
                    if not product or repo.product == product]
        return self.rdb.find_repos(**kwargs)

    def ycm_works(self):
        """Return True if the version of yum installed fixes known
        yum-config-manager bugs"""
        try:
            return self._working_ycm
        except AttributeError:
            if not self.oscs.verify_package('yum-utils'):
                self._working_ycm = False
                return self._working_ycm
            pkg_ycm = self.oscs.installed_package_matching(WORKING_YCM_NVR[0])
            if pkg_ycm:
                ycm_nvr = (pkg_ycm.name, pkg_ycm.ver, pkg_ycm.rel)
                self._working_ycm = (
                    rpm.labelCompare(ycm_nvr,
                                     WORKING_YCM_NVR) >= 0)
            else:
                self._working_ycm = False
            return self._working_ycm

    def _set_local_change(self, repoid, value):
        repo = self.oscs.repo_for_repoid(repoid)
        repofile = normpath(repo.repofile)
        if repofile not in self.local_changes:
            self.local_changes[repofile] = {}
        self.local_changes[repofile][repoid] = value

    def _available_subs(self):
        subs = {}
        for fxn_rcheck, sub in [(self.oscs.repo_is_rhsm, 'rhsm'),
                                (self.oscs.repo_is_rhn, 'rhn')]:
            for repoid in self.oscs.all_repoids():
                if fxn_rcheck(repoid):
                    subs[sub] = True
                    break
        return subs

    def _sub(self, subscription):
        self.opts.subscription = subscription
        self.logger.info('Detected OpenShift repository '
                         'subscription managed by %s' %
                         SUBS_NAME[self.opts.subscription])

    def _oo_ver(self, version):
        self.opts.oo_version = version
        self.logger.info('Detected OpenShift version %s' %
                         self.opts.oo_version)

    def _sub_ver(self, subscription, version=None):
        if self.opts.subscription == UNKNOWN and not self.opts.oo_version:
            self._sub(subscription)
            if version:
                self._oo_ver(version)
                return True
            # We still haven't gotten a version guess - fail to force
            # user to specify version
            return False
        if self.opts.subscription == UNKNOWN and self.opts.oo_version:
            if not version or version == self.opts.oo_version:
                self._sub(subscription)
                return True
        if self.opts.subscription != UNKNOWN and not self.opts.oo_version:
            if subscription == self.opts.subscription and version:
                self._oo_ver(version)
                return True
        if self.opts.subscription != UNKNOWN and self.opts.oo_version:
            if (subscription == self.opts.subscription and
                (not version or version == self.opts.oo_version)):
                return True
        return False

    def detect_prod_version_and_sub(self):
        """Attempt to determine if an existing version of OpenShift is
        installed, and if so, guess what version (out of the available
        versions in the repository config file) is installed

        """
        if self.opts.subscription != UNKNOWN and self.opts.oo_version:
            # Short-circuit guess if user specifies sub and ver
            return True
        enabled_repos = [repo for repo in
                         self.rdb.find_repos_by_repoid(
                             self.oscs.enabled_repoids()) if
                         not isinstance(repo.product_version, tuple)]
        pkg_repos = [repo for repo in enabled_repos if
                     self.oscs.verify_package(repo.key_pkg, source=repo.repoid)]
        for repos in (pkg_repos, enabled_repos):
            if not repos:
                continue
            if self.rdb.preferred_version and not self.opts.oo_version:
                ver_mtch = [repo for repo in repos if
                            repo.product_version ==
                            self.rdb.preferred_version]
                if ver_mtch:
                    if self.opts.subscription != UNKNOWN:
                        return self._sub_ver(self.opts.subscription,
                                             self.rdb.preferred_version)
                    self._oo_ver(self.rdb.preferred_version)
            if self.opts.oo_version:
                repos = [repo for repo in repos if
                         repo.product_version == self.opts.oo_version]
                if not repos:
                    continue
            if self.rdb.preferred_subscription:
                subs_mtch = [repo for repo in repos if
                             repo.subscription ==
                             self.rdb.preferred_subscription]
                if subs_mtch:
                    mtch_repo = subs_mtch[0]
                    return self._sub_ver(mtch_repo.subscription,
                                         mtch_repo.product_version)
            mtch_repo = repos[0]
            return self._sub_ver(mtch_repo.subscription,
                                 mtch_repo.product_version)
        avail_subs = self._available_subs()
        if avail_subs:
            if avail_subs.get(self.rdb.preferred_subscription, False):
                # Get the preferred subscription if available
                return self._sub_ver(self.rdb.preferred_subscription)
            # Get first valid subscription otherwise
            return self._sub_ver(avail_subs.keys()[0])
        return False


    def _output_version_conflicts(self):
        self.logger.error('Repositories have been found which conflict with '
                          'the detected or specified product version.')
        self.logger.error('To prevent problems due to package conflicts, '
                          'disable these repositories according to the '
                          'directions given below.')
        if self.managed_changes[RHSM]:
            for repoid in self.managed_changes[RHSM].iterkeys():
                self.logger.error('Disable RHSM-managed repositories which '
                                  'have existing content overrides by '
                                  'running:')
                self.logger.error('    # subscription-manager repos '
                                  '--disable=%s' % repoid)
        if self.managed_changes[RHN]:
            self.logger.error('Disable RHN-managed repositories by making '
                              'these modifications to '
                              '/etc/yum/pluginconf.d/rhnplugin.conf:')
            for repoid in self.managed_changes[RHN].iterkeys():
                self.logger.error('    Set "enabled=0" in the "[%s]" '
                                  'section, creating the section if needed' %
                                  repoid)
        if self.local_changes:
            if self.ycm_works():
                self.logger.error('Disable Yum and/or RHSM-managed '
                                  'repositories with local settings by '
                                  'running these commands:')
                for repofile, changes in self.local_changes.iteritems():
                    for repoid in changes.iterkeys():
                        self.logger.error('    # yum-config-manager '
                                          '--disable %s' % repoid)
            else:
                self.logger.error('Disable Yum and/or locally-managed RHSM '
                                  'repositories by modifying the following '
                                  'file(s).')
                for repofile, changes in self.local_changes.iteritems():
                    self.logger.error('Update %s with the following '
                                      'changes:' % repofile)
                    for repoid in changes.iterkeys():
                        self.logger.error('    Set "enabled=0" in the '
                                          '[%s] section, creating the '
                                          'section if needed' % repoid)

    def check_version_conflict(self):
        """Determine if repositories for multiple versions of OpenShift have
        been wrongly enabled, and advise or fix accordingly.
        """
        matches = self.rdb.find_repos_by_repoid(self.oscs.enabled_repoids())
        conflicts = [repo for repo in matches if
                     (not hasattr(repo.product_version, '__iter__') and
                      not (repo.product_version == self.opts.oo_version) or
                      not (repo.subscription == self.opts.subscription))]
        if conflicts:
            self.problem = True
            if self.opts.fix:
                for repo in conflicts:
                    if self.oscs.disable_repo(repo.repoid):
                        self.logger.warning('Disabled repository %s' %
                                            repo.repoid)
            else:
                self.managed_changes = {RHSM: {}, RHN: {}}
                self.local_changes = {}
                rhsm_conflicts = [repo.repoid for repo in conflicts if
                                  self.oscs.repo_is_rhsm(repo.repoid)]
                rhn_conflicts = [repo.repoid for repo in conflicts if
                                 self.oscs.repo_is_rhn(repo.repoid)]
                other_conflicts = [repo.repoid for repo in conflicts if
                                   not (repo.repoid in rhsm_conflicts or
                                        repo.repoid in rhn_conflicts)]
                if rhsm_conflicts:
                    for repoid in rhsm_conflicts:
                        if self.oscs.repo_attr_overridden(repoid, 'enabled'):
                            self.managed_changes[RHSM][repoid] = 0
                        else:
                            self._set_local_change(repoid, 0)
                if rhn_conflicts:
                    for repoid in rhn_conflicts:
                        self.managed_changes[RHN][repoid] = 0
                if other_conflicts:
                    for repoid in other_conflicts:
                        self._set_local_change(repoid, 0)
                self._output_version_conflicts()
            return False
        return True


    def verify_yum_plugin_priorities(self):
        """Determine if the required yum plugin package yum-plugin-priorities
        is installed. No action should be taken if the package can't
        be found (advise only)

        """
        self.logger.info('Checking if yum-plugin-priorities is installed')
        try:
            if not self.oscs.verify_package('yum-plugin-priorities'):
                self.problem = True
                if self.oscs.package_available('yum-plugin-priorities'):
                    self.logger.error('Required package yum-plugin-priorities '
                                      'is not installed. Install the package '
                                      'with the following command:')
                    self.logger.error('    # yum install '
                                      'yum-plugin-priorities')
                else:
                    self.logger.error('Required package yum-plugin-priorities '
                                      'is not available.')
                return False
        except Errors.RepoError as exc:
            raise UnrecoverableYumError(exc)
        return True

    def _get_pri(self, repoid):
        return self.resolved_repos.get(repoid, self.oscs.repo_priority(repoid))

    def _limit_pri(self, repolist, minpri=False):
        """Determine the highest or lowest priority for the provided repos,
        depending on minpri value
        """
        res = -1
        c_fxn, p_limit = max, 0
        if minpri:
            c_fxn, p_limit = min, 99
        res = c_fxn(chain((self._get_pri(repoid) for
                           repoid in repolist), [p_limit]))
        return res

    def _set_pri(self, repoid, priority):
        self.problem = True
        if not self.pri_header:
            self.pri_header = True
            self.logger.info('Resolving repository/channel/subscription '
                             'priority conflicts')
        if self.opts.fix:
            self.logger.warning('Setting priority for repository %s to %d' %
                                (repoid, priority))
            self.oscs.set_repo_priority(repoid, priority)
        else:
            if self.oscs.repo_is_rhn(repoid):
                self.managed_changes[RHN][repoid] = priority
            elif self.oscs.repo_is_rhsm(repoid) and self.oscs.repo_attr_overridden(repoid, 'priority'):
                self.managed_changes[RHSM][repoid] = priority
            else:
                self._set_local_change(repoid, priority)

    def _commit_resolved_pris(self):
        self.managed_changes = {RHSM: {}, RHN: {}}
        self.local_changes = {}
        for repoid, pri in sorted(self.resolved_repos.items(),
                                  key=lambda (kk, vv): vv):
            if not self.committed_resolved_repos.get(repoid, None) == pri:
                self._set_pri(repoid, pri)
        if self.managed_changes[RHSM]:
            self.logger.error('To resolve conflicting repositories, '
                              'update repo priority by running:')
            for repoid, priority in self.managed_changes[RHSM].iteritems():
                self.logger.error('    # subscription-manager repo-override '
                                  '--repo=%s --add=priority:%d' %
                                  (repoid, priority))
        if self.managed_changes[RHN]:
            self.logger.error('To resolve conflicting repositories, '
                              'update '
                              '/etc/yum/pluginconf.d/rhnplugin.conf '
                              'with the following changes:')
            for repoid, priority in self.managed_changes[RHN].iteritems():
                self.logger.error('    Set "priority=%d" in the "[%s]" '
                                  'section, creating the section if needed' %
                                  (priority, repoid))
        if self.local_changes:
            if self.ycm_works():
                self.logger.error('To resolve conflicting repositories, '
                                  'update repo priority by running:')
                for repofile, changes in self.local_changes.iteritems():
                    for repoid, priority in changes.iteritems():
                        self.logger.error('    # yum-config-manager '
                                          '--setopt=%s.priority=%d %s --save' %
                                          (repoid, priority, repoid))
            else:
                for repofile, changes in self.local_changes.iteritems():
                    self.logger.error('To resolve conflicting repositories, '
                                      'update %s '
                                      'with the following changes:' % repofile)
                    for repoid, priority in changes.iteritems():
                        self.logger.error('    Set "priority=%d" in the '
                                          '[%s] section, creating the '
                                          'section if needed' %
                                          (priority, repoid))
        self.committed_resolved_repos = self.resolved_repos.copy()

    def _multiple_eap_roles(self):
        return len(set(EAP_ROLES).intersection(self.opts.role)) > 1

    def _check_valid_pri(self, repos):
        bad_repos = [(repoid, self._get_pri(repoid)) for
                     repoid in repos if self._get_pri(repoid) >= 99]
        if bad_repos:
            self.problem = True
            self.logger.error('The calculated priorities for the following '
                              'repoids are too large (>= 99)')
            for repoid, pri in bad_repos:
                self.logger.error('    %s'%repoid)
            self.logger.error('Please re-run this script with the --fix '
                              'argument to set an appropriate priority, '
                              'or update the system priorities by hand')
            return False
        return True

    def verify_rhel_priorities(self, ose_repos, rhel6_repos):
        """Check that the base Red Hat Enterprise Linux repositories are lower
        priority than the OpenShift repositories and fix or advise
        accordingly

        """
        res = True
        ose_pri = self._limit_pri(ose_repos)
        rhel_pri = self._limit_pri(rhel6_repos, minpri=True)
        required_repos = self.blessed_repoids(enabled=True, required=True)
        if rhel_pri <= ose_pri:
            for repoid in ose_repos:
                if repoid in required_repos and self._get_pri(repoid) != OSE_PRIORITY:
                    self.resolved_repos[repoid] = OSE_PRIORITY
                if repoid not in required_repos and self._get_pri(repoid) < OTHER_PRIORITY:
                    self.resolved_repos[repoid] = OTHER_PRIORITY
            res = False
            ose_pri = OSE_PRIORITY
        # Fix the rhel repos if any of them are at 99
        if rhel_pri <= ose_pri or self._limit_pri(rhel6_repos) >= 99:
            for repoid in rhel6_repos:
                if repoid in required_repos and self._get_pri(repoid) != RHEL_PRIORITY:
                    self.resolved_repos[repoid] = RHEL_PRIORITY
                if repoid not in required_repos and self._get_pri(repoid) < OTHER_PRIORITY:
                    self.resolved_repos[repoid] = OTHER_PRIORITY
            res = False
        return res

    def _verify_jboss_eap_priorities(self):
        # Set non-specified/guessed EAP role to OTHER_PRIORITY since
        # they won't necessarily have package conflicts to trigger
        # priority shufflin' UNTIL IT'S TOO LATE!
        res = True
        other_roles = list(set(EAP_ROLES).difference(self.opts.role))
        d_cardinality = len(EAP_ROLES) - len(other_roles)
        other_repos = set()
        repos_to_remove = []
        # more than 1 EAP role is selected
        if d_cardinality > 1:
            raise YumValidatorError('multiple node-eap* roles are set; these '
                                    'roles are mutually exclusive')
        # at least 1 EAP role is selected
        elif d_cardinality > 0:
            for other_role in other_roles:
                other_repos = other_repos.union(self.rdb.find_repoids(
                    role=other_role,
                    product='jboss'))
        # Don't do work if there's no repos to work on
        if other_repos:
            other_repos = list(other_repos.intersection(
                self.oscs.enabled_repoids()))
            required_jboss_repos = self.blessed_repoids(enabled=True,
                                                        required=True,
                                                        product='jboss')
            for repoid in other_repos:
                if not self.verify_repo_priority(repoid, required_jboss_repos):
                    repos_to_remove.append(repoid)
        return res, repos_to_remove

    def verify_jboss_priorities(self, ose_repos, jboss_repos, rhel6_repos=None):
        """Check that the JBoss EAP and EWS repositories are lower priority
        than the base Red Hat Enterprise Linux repositories and fix or
        advise accordingly

        """
        res, repos_to_remove = self._verify_jboss_eap_priorities()
        jboss_repos = [repoid for repoid in jboss_repos if not (repoid in repos_to_remove)]
        min_pri = self._limit_pri(ose_repos)
        jboss_pri = self._limit_pri(jboss_repos, minpri=True)
        jboss_max_pri = self._limit_pri(jboss_repos)
        required_jboss_repos = self.blessed_repoids(
            enabled=True, required=True, product='jboss')
        if rhel6_repos:
            min_pri = self._limit_pri(rhel6_repos)
        if jboss_pri <= min_pri or jboss_max_pri >= 99:
            if rhel6_repos:
                for repoid in (repoid for repoid in rhel6_repos if
                               self._get_pri(repoid) != RHEL_PRIORITY):
                    self.resolved_repos[repoid] = RHEL_PRIORITY
            res = False
            for repoid in jboss_repos:
                if repoid in required_jboss_repos and self._get_pri(repoid) != JBOSS_PRIORITY:
                    self.resolved_repos[repoid] = JBOSS_PRIORITY
                elif repoid not in required_jboss_repos and self._get_pri(repoid) < OTHER_PRIORITY:
                    self.resolved_repos[repoid] = OTHER_PRIORITY
        return res

    def verify_priorities(self):
        """Verify that the relative priorities of the blessed repositories are
        correctly ordered and fix or advise accordingly

        """
        res = True
        self.logger.info('Checking channel/repository priorities')
        ose_scl = self.blessed_repoids(enabled=True, required=False,
                                       product='ose')
        ose_scl += self.blessed_repoids(enabled=True, required=False,
                                        product='rhscl')
        jboss = self.blessed_repoids(enabled=True, required=False,
                                     product='jboss')
        rhel = self.blessed_repoids(enabled=True, product='rhel')
        if rhel:
            res &= self.verify_rhel_priorities(ose_scl, rhel)
        # Feed only required ose/scl repos to verify_jboss_priorities
        ose_scl = [repoid for repoid
                   in self.blessed_repoids(enabled=True, required=True)
                   if repoid in ose_scl]
        if jboss:
            if rhel:
                res &= self.verify_jboss_priorities(ose_scl, jboss, rhel)
            else:
                res &= self.verify_jboss_priorities(ose_scl, jboss)
        return res

    def _output_disabled_repos(self, disabled_repos):
        self.managed_changes = {RHSM: {}, RHN: {}}
        self.local_changes = {}
        for repoid in disabled_repos:
            if self.oscs.repo_is_rhn(repoid):
                self.managed_changes[RHN][repoid] = 1
            elif (self.oscs.repo_is_rhsm(repoid) and
                  self.oscs.repo_attr_overridden(repoid, 'enabled')):
                self.managed_changes[RHSM][repoid] = 1
            else:
                self._set_local_change(repoid, 1)
        self.logger.error('Required OpenShift repositories have been found '
                          'which are currently disabled. Enable them '
                          'according to the following directions.')
        if self.managed_changes[RHSM]:
            self.logger.error('Enable RHSM-managed repos which have existing '
                              'content overrides by running:')
            for repoid in self.managed_changes[RHSM].iterkeys():
                self.logger.error('    # subscription-manager repos '
                                  '--enable=%s' % repoid)
        if self.managed_changes[RHN]:
            self.logger.error('Enable RHN-managed repos by making these '
                              'modifications to '
                              '/etc/yum/pluginconf.d/rhnplugin.conf:')
            for repoid in self.managed_changes[RHN].iterkeys():
                self.logger.error('    Set "enabled=1" in the "[%s]" '
                                  'section, creating the section if '
                                  'needed' % repoid)
        if self.local_changes:
            if self.ycm_works():
                self.logger.error('Enable Yum and/or locally-managed RHSM '
                                  'repositories by running:')
                for repofile, changes in self.local_changes.iteritems():
                    for repoid in changes.iterkeys():
                        self.logger.error('    # yum-config-manager --enable '
                                          '%s' % repoid)
            else:
                self.logger.error('Enable Yum and/or locally-managed RHSM '
                                  'repositories by modifying the following '
                                  'file(s).')
                for repofile, changes in self.local_changes.iteritems():
                    self.logger.error('Update %s with the following '
                                      'changes:' % repofile)
                    for repoid in changes.iterkeys():
                        self.logger.error('    Set "enabled=1" in the "[%s]" '
                                          'section, creating the section if '
                                          'needed' % repoid)

    def check_disabled_repos(self):
        """Check if any required repositories are disabled, and fix or advise
        accordingly
        """
        disabled_repos = list(set(self.blessed_repoids(required=True))
                              .intersection(self.oscs.disabled_repoids()))
        if disabled_repos:
            self.problem = True
            if self.opts.fix:
                for repo in disabled_repos:
                    if self.oscs.enable_repo(repo):
                        self.logger.warning('Enabled repository %s'%repo)
            else:
                self._output_disabled_repos(disabled_repos)
            return False
        return True

    def check_missing_repos(self):
        """Check if any required repositories are missing, and advise
        accordingly

        """
        missing_repos = [repo for repo in
                         self.blessed_repoids(required=True)
                         if repo not in self.oscs.all_repoids()]
        if missing_repos:
            self.problem = True
            self.logger.error('The required OpenShift repositories are '
                              'missing:')
            for repo in missing_repos:
                self.logger.error('    %s'%repo)
            self.logger.error('Please verify that an OpenShift subscription is '
                              'attached to this system using either RHN '
                              'Classic or Red Hat Subscription Manager by '
                              'following the instructions here: %s' %
                              ATTACH_ENTITLEMENTS_URL)
            return False
        return True

    def verify_repo_priority(self, repoid, required_repos):
        """Checks the given repoid to make sure that the priority for it
        doesn't conflict with required repository priorities

        Preconditions: Maximum OpenShift (and blessed) repository
        priority should be below 99
        """
        res = True
        required_pri = self._limit_pri(required_repos)
        new_pri = OTHER_PRIORITY
        if self._get_pri(repoid) <= required_pri:
            if required_pri >= new_pri:
                new_pri = min(99, required_pri+10)
            # self._set_pri(repoid, new_pri)
            self.resolved_repos[repoid] = new_pri
            res = False
        return res


    def find_package_conflicts(self):
        """Search for packages from non-blessed repositories which could
        conflict with the "official" packages provided in the blessed
        repositories, determine an appropriate priority for the
        non-blessed repos to resolve the conflict, and fix or advise
        accordingly

        """
        res = True
        self.pri_resolve_header = False
        all_blessed_repos = self.rdb.find_repoids(
            product_version=self.opts.oo_version)
        enabled_ose_scl_repos = self.blessed_repoids(enabled=True,
                                                     required=True,
                                                     product='ose')
        enabled_ose_scl_repos += self.blessed_repoids(enabled=True,
                                                      required=True,
                                                      product='rhscl')
        enabled_jboss_repos = self.blessed_repoids(enabled=True,
                                                   required=True,
                                                   product='jboss')
        rhel6_repos = self.blessed_repoids(enabled=True, product='rhel')
        # if not rhel6_repo[0] in self.oscs.enabled_repoids():
        #     rhel6_repo = []
        required_repos = (enabled_ose_scl_repos + rhel6_repos +
                          enabled_jboss_repos)
        if not self._check_valid_pri(required_repos):
            return False
        for repoid in required_repos:
            try:
                ose_pkgs = self.oscs.packages_for_repo(repoid,
                                                       disable_priorities=True)
                ose_pkg_names = sorted(set([xx.name for xx in ose_pkgs]))
                matches = [xx for xx in
                           self.oscs.all_packages_matching(ose_pkg_names, True)
                           if xx.repoid not in all_blessed_repos]
                conflicts = sorted(set([xx.repoid for xx in matches]))
                for repo in conflicts:
                    res &= self.verify_repo_priority(repo, required_repos)
            except KeyError:
                self.logger.error('Repository %s not enabled'%repoid)
                res = False
            except Errors.RepoError as repo_err:
                raise UnrecoverableYumError(repo_err)
        return res

    def _set_exclude(self, repo):
        if self.opts.fix:
            self.logger.error('    %s: %s' %
                              (repo.repoid, ' '.join(repo.exclude)))
            self.oscs.merge_excludes(repo.repoid, list(repo.exclude))
        else:
            exc = ' '.join(repo.exclude)
            repoid = repo.repoid
            if self.oscs.repo_is_rhn(repoid):
                self.managed_changes[RHN][repoid] = exc
            elif self.oscs.repo_is_rhsm(repoid) and self.oscs.repo_attr_overridden(repoid, 'exclude'):
                self.managed_changes[RHSM][repoid] = exc
            else:
                self._set_local_change(repoid, exc)

    def _excludes_needed(self, repo):
        if repo.exclude and repo.repoid in self.oscs.all_repoids():
            cur_excl = self.oscs.repo_for_repoid(repo.repoid).exclude
            # see if current set exclusions are (improper) superset of repo.exclude
            return not (set(cur_excl) >= set(repo.exclude))

    def _output_excludes(self):
        if self.opts.fix:
            return
        self.logger.error('To prevent problems due to package conflicts, '
                          'modify these repositories according to the '
                          'directions given below.')
        if self.managed_changes[RHSM]:
            self.logger.error('Set package exclusions for RHSM-managed '
                              'repositories with existing content overrides '
                              'by running:')
            for repoid, exclusions in self.managed_changes[RHSM].iteritems():
                self.logger.error('    # subscription-manager repo-override '
                                  '--repo=%s --add=exclude:"%s"' %
                                  (repoid, exclusions))
        if self.managed_changes[RHN]:
            self.logger.error('Set package exclusions for RHN-managed repos '
                              'by updating '
                              '/etc/yum/pluginconf.d/rhnplugin.conf '
                              'with the following changes:')
            for repoid, exclusions in self.managed_changes[RHN].iteritems():
                self.logger.error('    Set "exclude=%s" in the "[%s]" section, '
                                  'creating the section if needed' %
                                  (exclusions, repoid))
        if self.local_changes:
            if self.ycm_works():
                self.logger.error('Set package exclusions for Yum '
                                  'repositories and/or locally-managed RHSM '
                                  'repositories by running:')
                for repofile, changes in self.local_changes.iteritems():
                    for repoid, exclusions in changes.iteritems():
                        self.logger.error('    # yum-config-manager '
                                          '--setopt=%s.exclude="%s" %s --save' %
                                          (repoid, exclusions, repoid))
            else:
                self.logger.error('Set package exclusions for Yum '
                                  'repositories and/or locally-managed RHSM '
                                  'repositories by making these '
                                  'modifications to the following file(s):')
                for repofile, changes in self.local_changes.iteritems():
                    self.logger.error('Update %s with the following '
                                      'changes:' % repofile)
                    for repoid, exclusions in changes.iteritems():
                        self.logger.error('    Set "exclude=%s" in the "[%s]" '
                                          'section, creating the section if '
                                          'needed' % (exclusions, repoid))


    def set_excludes(self):
        """Set any excludes configured for the required repositories
        """
        need_exclude = [repo for repo in self.required_repos() if
                        self._excludes_needed(repo)]
        if need_exclude:
            self.problem = True
            self.logger.error('Repositories have been found which are '
                              'missing one or more required package '
                              'exclusions.')
            if self.opts.fix:
                self.logger.error('To prevent problems due to package '
                                  'conflicts, package exclusions are being '
                                  'set for the following repositories:')
            else:
                self.managed_changes = {RHSM: {}, RHN: {}}
                self.local_changes = {}
            for repo in need_exclude:
                self._set_exclude(repo)
            self._output_excludes()
            return False
        return True

    def _guess_eap(self):
        # This method depends on EAP_ROLES being ordered from
        # lowest-version to highest-version pinned roles first, then
        # the unpinned "current" role at the end.
        en_eap_repos = {}
        enabled_rset = set(self.oscs.enabled_repoids())
        for role in EAP_ROLES:
            repos = set(self.rdb.find_repoids(role=role, product='jboss'))
            enabled = repos.intersection(enabled_rset)
            if enabled:
                en_eap_repos[role] = enabled
        favored = None
        # pick the lowest-version role with the lowest-priority
        # channel(s)
        if len(en_eap_repos) > 1:
            pri = {}
            for role, enabled in en_eap_repos.iteritems():
                pri[role] = self._limit_pri(
                    [self.oscs.repo_for_repoid(repoid) for repoid in
                     list(enabled)],
                    True)
                minpri = min(pri.itervalues())
            # EAP_ROLES is ordered from lowest-version to highest,
            # then "current"
            for role in EAP_ROLES:
                if role in pri and pri[role] == minpri:
                    favored = role
                    break
        elif len(en_eap_repos) == 1: # pick the only role
            favored = en_eap_repos.keys().pop()
        else:
            # pick the lowest-version pinned role detected
            for role in EAP_ROLES:
                if role in self.opts.role:
                    favored = role
                    break
        unfavored = [role for role in EAP_ROLES if role != favored and
                     role in self.opts.role]
        for role in unfavored:
            self.opts.role.remove(role)

    def guess_role(self):
        """Try to determine the system role by comparing installed packages to
        key packages

        """
        self.logger.warning('No roles have been specified. Attempting to '
                            'guess the roles for this system...')
        self.opts.role = []
        for role in VALID_ROLES:
            # get uniquified list of packages that coorespond to only one role
            check_pkgs = list(set([repo.key_pkg for repo in
                                   self.rdb.find_repos(role=role) if
                                   not hasattr(repo.role, '__iter__')]))
            present_pkgs = [self.oscs.installed_package_matching(pkg)
                            for pkg in check_pkgs if
                            self.oscs.verify_package(pkg)]
            if present_pkgs:
                self.opts.role.append(role)
                pkg_repos = flatten_uniq([self.rdb.find_repos(
                    key_pkg=pkg.name,
                    repoid=self.oscs.repo_for_package(pkg))
                                          for pkg in present_pkgs])
                # Peek ahead to see if we're possibly running an OSE install
                for repo in pkg_repos:
                    if not self.opts.product or repo.product == 'ose':
                        self.opts.product = repo.product
        if not self.opts.role:
            self.logger.error('No roles could be detected.')
            self.problem = True
            return False
        elif self._multiple_eap_roles():
            # We will detect all EAP roles since they share a key_pkg
            self._guess_eap()
        self.logger.warning('If the roles listed below are incorrect or '
                            'incomplete, please re-run this script with the '
                            'appropriate --role arguments')
        self.logger.warning('\n'.join(('    %s' %
                                       role for role in self.opts.role)))
        return True

    def validate_roles(self):
        """Check supplied roles against VALID_ROLES.

        """
        if not self.opts.role:
            return True
        for role in self.opts.role:
            if not role in VALID_ROLES:
                self.problem = True
                self.logger.error('You have specified an invalid role: %s '
                                  'is not one of %s' % (role, VALID_ROLES))
                return False
        if self._multiple_eap_roles():
            # If the user has specified both, bail out
            self.logger.info('You have specified multiple "node-eap" roles. '
                             'Only one of these roles can be specified, as '
                             'their associated repositories conflict. Please '
                             're-run the tool with only the appropriate '
                             'roles specified.')
            self.problem = True
            return False
        return True

    def reconcile_overrides(self):
        self.logger.info('Checking for discrepancies between local settings '
                         'and content overrides')
        from yumvalidator.reconcile_rhsm_config import ReconciliationEngine
        try:
            r_eng = ReconciliationEngine(self.oscs, self.rdb, self.logger, self.opts)
            if r_eng.reconcile_overrides():
                self.problem = True
                return False
        except Exception, rengex:
            # We can't recover from any error here
            raise SubscriptionManagerError(repr(rengex))
        return True

    def validate_version(self):
        """Check supplied product version against versions available in RepoDB
        object self.rdb

        """
        valid_vers = self.rdb.list_available('product_version')
        if self.opts.oo_version:
            if not self.opts.oo_version in valid_vers:
                self.logger.error('You have specified an invalid version: '
                                  '%s is not one of: %s' %
                                  (self.opts.oo_version, ', '.join(valid_vers)))
                self.problem = True
                return False
        return True

    def massage_roles(self):
        """Set supplied roles to lowercase, guarantee that the "node" role is
        set if "node-eap" is set, and advise user on "node-eap" role
        if "node" is set without "node-eap"

        """
        if not self.opts.role:
            self.guess_role()
        if self.opts.role:
            self.opts.role = [xx.lower() for xx in self.opts.role]
            for role in [nrole for nrole in VALID_ROLES
                         if nrole[:4] == 'node']:
                if role in self.opts.role and not 'node' in self.opts.role:
                    self.opts.role.append('node')
            if 'broker' in self.opts.role and not 'client' in self.opts.role:
                self.opts.role.append('client')
                self.logger.info('Please note: --role=broker implicitly '
                                 'enables --role=client to ensure /usr/bin/rhc '
                                 'is available for testing and '
                                 'troubleshooting.')

    def run_priority_checks(self):
        if not (self.verify_priorities() or self.opts.report_all):
            self._commit_resolved_pris()
            return False
        if not (self.find_package_conflicts() or self.opts.report_all):
            self._commit_resolved_pris()
            return False
        self._commit_resolved_pris()
        return True

    def run_checks(self):
        if not self.validate_roles():
            return False
        self.massage_roles()
        if not self.detect_prod_version_and_sub():
            self.problem = True
            if self.opts.subscription == UNKNOWN:
                self.logger.error('Could not determine subscription type.')
                self.logger.error('Please attach an OpenShift subscription to '
                                  'this system using either RHN Classic or Red '
                                  'Hat Subscription Manager by following the '
                                  'instructions here: %s' %
                                  ATTACH_ENTITLEMENTS_URL)
            if not self.opts.oo_version:
                self.logger.error('Could not determine product version. '
                                  'Please re-run this script with the '
                                  '--oo-version argument.')
            return False
        print ""
        if self.opts.reconcile_overrides:
            if not self.opts.subscription == RHSM or not self.oscs.use_override():
                self.logger.error('The --reconcile-overrides option only '
                                  'affects systems with OpenShift '
                                  'subscriptions managed by Red Hat '
                                  'Subscription Manager version %s or '
                                  'higher.' % SUBMAN_OVERRIDE_NVR[1])
            elif not self.reconcile_overrides():
                print ""
                if not self.opts.report_all:
                    return False
        if not (self.check_version_conflict() or self.opts.report_all):
            return False
        if not (self.check_disabled_repos() or self.opts.report_all):
            return False
        if not (self.check_missing_repos() or self.opts.report_all):
            return False
        if self.opts.role:
            if not self.verify_yum_plugin_priorities():
                if not self.opts.report_all:
                    self.logger.warning('Skipping yum priorities verification')
                    return False
                else:
                    print ""
                    self.logger.warning('PLEASE NOTE: '
                                        'The yum-plugin-priorities package is '
                                        'not installed, so any information '
                                        'reported by this tool regarding '
                                        'repository priorities may not be '
                                        'accurate.')
                    print ""
            if not (self.run_priority_checks() or self.opts.report_all):
                return False
            if not (self.set_excludes() or self.opts.report_all):
                return False
        else:
            self.logger.warning('Please specify at least one role for this '
                                'system with the --role command')
            self.problem = True
            return False
        if not self.problem:
            self.logger.info('No problems could be detected!')
            return True
        return False

    def main(self):
        if not self.validate_version():
            return 1
        if self.opts.report_all:
            # report_all + fix == fix_all, we don't want someone to
            # accidentally set that up by hand
            self.opts.fix = False
        if self.opts.fix_all:
            self.opts.report_all = True
            self.opts.fix = True
        try:
            self.run_checks()
            if not self.opts.fix and self.problem:
                self.logger.info('Please re-run this tool after making '
                                 'any recommended repairs to this system')
            if self.problem:
                return 1
        except UnrecoverableYumError, uryum_err:
            self.logger.critical('An unrecoverable error prevents further '
                                 'checks from being run. Re-run this tool '
                                 'after the problem has been repaired:')
            print ''
            self.logger.critical(uryum_err)
            return 128
        except SubscriptionManagerError, sm_err:
            self.logger.critical('A problem occured while using '
                                 'subscription-manager services. This often '
                                 'indicates a problem communicating with the '
                                 'subscription-manager server component. '
                                 'Please resolve the issue and try again.')
            print ''
            self.logger.critical(sm_err)
            return 2
        return 0


def validate_yum():
    ROLE_HELP = 'OpenShift component role(s) this system will fulfill.'
    OO_VERSION_HELP = 'Version of OpenShift in use on this system.'
    SUBSCRIPTION_HELP = ('Subscription management system which provides the '
                         'OpenShift repositories/channels.')
    FIX_HELP = 'Attempt to repair the first problem found.'
    FIX_ALL_HELP = 'Attempt to repair all problems found.'
    REPORT_ALL_HELP = ('Report all problems (default is to halt after first '
                       'problem report.)')
    REPO_CONF_HELP = ('Load blessed repository data from the specified file '
                      'instead of built-in values')
    USER_REPOS_HELP = ('Requires --repo-config. Blend the repository data '
                       'loaded via --repo-config with the built-in values')
    RECONCILE_OVERRIDES_HELP = ('Checks RHSM repos for local settings that '
                                'differ from settings stored remotely as '
                                'content overrides, and commutes the local '
                                'values to content overrides.')

    # TODO: This is getting unwieldy - time for a wrapper?
    try:
        import argparse
        opt_parser = argparse.ArgumentParser()
        opt_parser.add_argument('-r', '--role', default=None,
                                choices=VALID_ROLES, action='append',
                                help=ROLE_HELP)
        opt_parser.add_argument('-o', '--oo_version', '--oo-version',
                                default=None,
                                dest='oo_version',
                                help=OO_VERSION_HELP)
        opt_parser.add_argument('-s', '--subscription-type',
                                default=None, choices=VALID_SUBS,
                                dest='subscription',
                                help=SUBSCRIPTION_HELP)
        opt_parser.add_argument('-f', '--fix', action='store_true',
                                default=False, help=FIX_HELP)
        opt_parser.add_argument('-a', '--fix-all',
                                action='store_true', default=False,
                                dest='fix_all', help=FIX_ALL_HELP)
        opt_parser.add_argument('-p', '--report-all',
                                action='store_true', default=False,
                                dest='report_all',
                                help=REPORT_ALL_HELP)
        opt_parser.add_argument('-c', '--repo-config', default=None,
                                type=str, help=REPO_CONF_HELP)
        opt_parser.add_argument('-e', '--reconcile-overrides', action='store_true',
                                default=False, help=RECONCILE_OVERRIDES_HELP)
        opts = opt_parser.parse_args()
    except ImportError:
        import optparse
        ROLE_HELP += ' One or more of: %s' % VALID_ROLES
        SUBSCRIPTION_HELP += ' One of: %s' % VALID_SUBS
        opt_parser = optparse.OptionParser()
        opt_parser.add_option('-r', '--role', default=None,
                              choices=VALID_ROLES, action='append',
                              help=ROLE_HELP)
        opt_parser.add_option('-o', '--oo_version', '--oo-version',
                              default=None, dest='oo_version',
                              help=OO_VERSION_HELP)
        opt_parser.add_option('-s', '--subscription-type',
                              default=None, choices=VALID_SUBS,
                              dest='subscription',
                              help=SUBSCRIPTION_HELP)
        opt_parser.add_option('-f', '--fix', action='store_true',
                              default=False, help=FIX_HELP)
        opt_parser.add_option('-a', '--fix-all', action='store_true',
                              default=False, dest='fix_all', help=FIX_ALL_HELP)
        opt_parser.add_option('-p', '--report-all',
                              action='store_true', default=False,
                              dest='report_all', help=REPORT_ALL_HELP)
        opt_parser.add_option('-c', '--repo-config', default=None,
                              type='string', help=REPO_CONF_HELP)
        opt_parser.add_option('-e', '--reconcile-overrides', action='store_true',
                              default=False, help=RECONCILE_OVERRIDES_HELP)
        (opts, args) = opt_parser.parse_args()
    opts.user_repos_only = True
    try:
        yum_vdtr = OpenShiftYumValidator(opts, opt_parser)
    except repo_db.RepoDBError as repo_err:
        sys.stderr.write("{0}\n".format(repo_err))
        sys.exit(1)
    sys.exit(yum_vdtr.main())

if __name__ == "__main__":
    validate_yum()
